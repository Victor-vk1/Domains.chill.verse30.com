<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title> </title>
<style>
  :root{
    --accent: #00ffa7;
    --glass-border: rgba(255,255,255,0.12);
    --muted: rgba(255,255,255,0.78);
    --card-radius: 20px;
    --ui-z: 60;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;-webkit-font-smoothing:antialiased}
  a{color:inherit}
  /* blurred background image */
  .bg{
    position:fixed; inset:0; z-index:0;
    background: url('/mnt/data/My Portfolio  _  Design  _  Artwork.jpeg') center/cover no-repeat;
    filter: saturate(.95) contrast(.92) blur(6px) brightness(.82);
  }
  /* canvases stacked */
  canvas.full { position:fixed; inset:0; z-index:1; pointer-events:none; display:block; width:100%; height:100%; }
  /* UI shell */
  .shell { position:relative; z-index:var(--ui-z); height:100vh; display:flex; align-items:center; justify-content:center; padding:28px; pointer-events:none; }
  /* Slim glass login card */
  .card {
    width:360px; padding:18px; border-radius:18px;
    background: linear-gradient(180deg, rgba(255,255,255,0.045), rgba(255,255,255,0.02));
    border:1px solid var(--glass-border);
    backdrop-filter: blur(22px) saturate(140%);
    box-shadow: 0 36px 110px rgba(0,0,0,0.7);
    position:relative; overflow:visible; pointer-events:auto; user-select:none; touch-action:none;
    transform-origin:center;
  }
  /* canvas that covers card (for WebGL metaballs local) */
  canvas.card-canvas { position:absolute; inset:-28px; z-index:2; border-radius:24px; pointer-events:none; mix-blend-mode:overlay; filter: blur(6px) saturate(1.2); }
  .inner { position:relative; z-index:10; }
  .hdr { display:flex; gap:12px; align-items:center; }
  .logo { width:56px;height:56px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.12),rgba(255,255,255,0.02));display:flex;align-items:center;justify-content:center;font-weight:800 }
  .title { font-size:20px; font-weight:800; }
  .subtitle { font-size:12px; color:var(--muted); margin-top:6px; }
  .input { width:100%; padding:12px 14px; border-radius:12px; border:none; outline:none; background: rgba(255,255,255,0.06); color:#fff; margin-top:12px; font-size:14px; }
  .btn { width:100%; margin-top:14px; padding:12px; border-radius:12px; border:none; cursor:pointer; font-weight:800; background:linear-gradient(180deg,var(--accent),#00e59a); color:#08110f; }
  .smallText { font-size:13px; color:var(--muted); margin-top:10px; text-align:center; }
  /* Dashboard */
  .dashboardWrap { display:none; padding:28px; z-index:50; pointer-events:auto; }
  .dashboard { width:min(1120px,94vw); max-width:1120px; height:min(78vh,820px); margin:0 auto; display:flex; gap:18px; align-items:flex-start; }
  .side { width:220px; }
  .menuCard { padding:14px; border-radius:18px; background: linear-gradient(180deg, rgba(255,255,255,0.035), rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.06); backdrop-filter: blur(16px); box-shadow: 0 18px 60px rgba(0,0,0,0.6); }
  .menuTitle { font-weight:800; font-size:14px; }
  .menuList { margin-top:12px; display:flex; flex-direction:column; gap:10px; }
  .menuBtn { padding:12px; border-radius:12px; cursor:pointer; background:transparent; color:#fff; text-align:left; border:1px solid transparent; transition: .18s; }
  .menuBtn:hover { transform: translateY(-3px); background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); }
  .active { background: linear-gradient(90deg, rgba(0,255,170,0.06), rgba(0,210,255,0.03)); border:1px solid rgba(0,255,170,0.09); }
  .centerArea { flex:1; display:flex; align-items:center; justify-content:center; min-height:420px; }
  .domainCard { width:640px; max-width:94%; height:420px; border-radius:22px; overflow:hidden; position:relative; background: linear-gradient(180deg, rgba(10,8,20,0.55), rgba(0,0,0,0.65)); border:1px solid rgba(255,255,255,0.06); box-shadow: 0 30px 80px rgba(0,0,0,0.6); }
  .domainCard .art { position:absolute; inset:0; background-size:cover; background-position:center; filter: contrast(1.02) saturate(1.05); }
  .domainCard .content { position:absolute; left:28px; bottom:30px; color:white; z-index:8; width:calc(100% - 56px); }
  .domainCard h2 { margin:0; font-size:28px; font-weight:800; }
  .domainCard p { margin-top:8px; color:var(--muted); }
  .join { margin-top:14px; padding:12px 16px; border-radius:12px; border:none; font-weight:800; background: linear-gradient(180deg, var(--accent), #00d59a); color:#08110f; cursor:pointer; }
  /* modals */
  .modalBack { position:fixed; inset:0; z-index:120; background: rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; }
  .modal { width:420px; max-width:92%; padding:18px; border-radius:14px; background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.06); box-shadow: 0 20px 60px rgba(0,0,0,0.7); }
  @media (max-width:900px) {
    .dashboard { flex-direction:column; gap:12px; align-items:center; height:auto; }
    .side { width:92%; }
    .centerArea { width:92%; }
    .domainCard { height:380px; }
    .card { width:92vw; }
  }
</style>
</head>
<body>
  <div class="bg" aria-hidden="true"></div>

  <!-- Global canvases for effects -->
  <canvas id="glCanvas" class="full" aria-hidden="true"></canvas> <!-- WebGL for metaballs+refraction -->
  <canvas id="sunCanvas" class="full" aria-hidden="true"></canvas> <!-- 2D sun & rays -->
  <canvas id="particlesCanvas" class="full" aria-hidden="true"></canvas> <!-- soft particles -->

  <div class="shell" id="shell">
    <div class="card" id="loginCard" role="dialog" aria-label="Domain Login">
      <canvas id="cardCanvas" class="card-canvas"></canvas>
      <div class="inner">
        <div class="hdr">
          <div class="logo">DV</div>
          <div>
            <div class="title">Domain Login</div>
            <div class="subtitle">Login to access domains</div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <input id="loginEmail" class="input" placeholder="Email address" type="email" autocomplete="email">
          <input id="loginUser" class="input" placeholder="Username" autocomplete="username">
          <input id="loginPass" class="input" placeholder="Password" type="password" autocomplete="current-password">
          <button id="loginBtn" class="btn">Log in</button>
          <div class="smallText">Sliding transition on success. Prefers-reduced-motion honored.</div>
        </div>
      </div>
    </div>
  </div>

  <div class="dashboardWrap" id="dashboardWrap">
    <div class="dashboard" id="dashboard">
      <div class="side">
        <div class="menuCard">
          <div class="menuTitle">Domains</div>
          <div class="menuList" id="menuList">
            <button class="menuBtn active" data-id="cvwt"><strong>CVWT</strong><div style="font-size:12px;color:var(--muted)">Chill Verse Website Testers</div></button>
            <button class="menuBtn" data-id="coders"><strong>Coders Association</strong><div style="font-size:12px;color:var(--muted)">Code, collab, ship</div></button>
            <button class="menuBtn" data-id="editors"><strong>Editors Club</strong><div style="font-size:12px;color:var(--muted)">Editorial & curation</div></button>
            <button class="menuBtn" data-id="office"><strong>Office Holders Verse</strong><div style="font-size:12px;color:var(--muted)">Leaders & roles</div></button>
          </div>
          <div style="margin-top:12px; display:flex; gap:8px;">
            <button id="logoutBtn" class="menuBtn" style="flex:1;background:rgba(255,255,255,0.02)">Logout</button>
            <button id="settingsBtn" class="menuBtn" style="width:44px">⚙</button>
          </div>
        </div>
      </div>

      <div class="centerArea">
        <div id="domainCard" class="domainCard">
          <div class="art" id="domainArt" style="background-image: url('/mnt/data/My Portfolio  _  Design  _  Artwork.jpeg')"></div>
          <div class="content">
            <h2 id="domainTitle">CVWT</h2>
            <p id="domainDesc">Chill Verse Website Testers — test, QA and chill with website builds.</p>
            <button class="join" id="joinBtn">Join</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modals -->
  <div id="authModal" style="display:none;">
    <div class="modalBack">
      <div class="modal" role="dialog" aria-modal="true">
        <div style="font-weight:800; margin-bottom:8px">Re-enter password to view</div>
        <input id="rePass" class="input" type="password" placeholder="Password">
        <div style="display:flex; gap:8px; margin-top:12px;">
          <button id="reSubmit" class="btn" style="flex:1">Confirm</button>
          <button id="reCancel" class="input" style="width:110px; background: rgba(255,255,255,0.02)">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <div id="joinModal" style="display:none;">
    <div class="modalBack">
      <div class="modal">
        <div style="font-weight:800; margin-bottom:6px">Join this domain</div>
        <div class="note" style="margin-bottom:8px">Enter the email to register for this domain.</div>
        <input id="joinEmail" class="input" placeholder="you@domain.com" type="email">
        <div style="display:flex; gap:8px; margin-top:12px;">
          <button id="joinSubmit" class="btn" style="flex:1">Submit</button>
          <button id="joinCancel" class="input" style="width:110px; background: rgba(255,255,255,0.02)">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <div id="successModal" style="display:none;">
    <div class="modalBack">
      <div class="modal">
        <div style="font-weight:800; margin-bottom:6px">Success</div>
        <div id="successMsg" class="note">You are registered — check your email.</div>
        <div style="display:flex; justify-content:flex-end; margin-top:12px;">
          <button id="succClose" class="btn" style="width:120px">Close</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ---------------------------
   CONFIG
   --------------------------- */
const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbyf-8LnQKKpIxzvY1QsVZI2jQF_7oMxprxCWrrFJTPDNBqrdZs_Folw4GZI2Iz5phM-_A/exec';
const CARD_ART_URL = '/mnt/data/My Portfolio  _  Design  _  Artwork.jpeg';

/* ---------------------------
   STATE & ELEMENTS
   --------------------------- */
const state = { logged:false, username:null, email:null, passwd:null, selectedDomain:'cvwt' };
const loginCard = document.getElementById('loginCard');
const cardCanvas = document.getElementById('cardCanvas'); // local webgl canvas for card
const glCanvas = document.getElementById('glCanvas'); // global webgl canvas (metaballs + refraction)
const sunCanvas = document.getElementById('sunCanvas'); // 2D for sun rays
const particlesCanvas = document.getElementById('particlesCanvas'); // particle layer
const shell = document.getElementById('shell');
const dashboardWrap = document.getElementById('dashboardWrap');
const domainArt = document.getElementById('domainArt');
const domainTitle = document.getElementById('domainTitle');
const domainDesc = document.getElementById('domainDesc');
const joinBtn = document.getElementById('joinBtn');
const menuButtons = Array.from(document.querySelectorAll('.menuBtn'));

/* Resize helpers */
function fitCardCanvas(){
  const rect = loginCard.getBoundingClientRect();
  cardCanvas.width = Math.round(rect.width + 60);
  cardCanvas.height = Math.round(rect.height + 60);
  cardCanvas.style.left = (rect.left - 30) + 'px';
  cardCanvas.style.top = (rect.top - 30) + 'px';
}
function fitFullCanvas(){
  const w = innerWidth, h = innerHeight;
  glCanvas.width = w; glCanvas.height = h;
  sunCanvas.width = w; sunCanvas.height = h;
  particlesCanvas.width = w; particlesCanvas.height = h;
}
window.addEventListener('resize', ()=>{ fitCardCanvas(); fitFullCanvas(); });
setTimeout(()=>{ fitCardCanvas(); fitFullCanvas(); }, 60);

/* ---------------------------
   WebGL setup (metaballs + chromatic ripple)
   We'll create a single WebGL program to render metaballs that react to pointer and produce a smooth field.
   --------------------------- */
function createGL(canvas){
  const gl = canvas.getContext('webgl2', { antialias: true, alpha: true }) || canvas.getContext('webgl', { antialias: true, alpha: true });
  return gl;
}

const gl = createGL(glCanvas);
let glSupported = !!gl;

/* if WebGL not supported, fallback to canvas2D metaballs (we implemented earlier)
   but in this file we prefer WebGL for Level 3 */
if (!glSupported){
  console.warn('WebGL not supported. Falling back to 2D metaballs and reduced effects.');
}

/* GLSL sources */
const vertSrc = `#version 300 es
precision highp float;
in vec2 a_pos;
out vec2 v_uv;
void main(){
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

/* Fragment shader: render metaballs (smooth union) + chromatic shift + soft vignette + subtle noise
   Inputs:
   - u_time
   - u_resolution
   - u_mouse (x,y)
   - u_blobs[n*3] => x,y,r
*/
const fragSrc = `#version 300 es
precision highp float;
out vec4 outColor;
in vec2 v_uv;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform int u_blobCount;
uniform vec3 u_blobs[64]; // x, y, radius

// simple pseudo-random
float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123); }
float noise(vec2 p){
  vec2 i = floor(p); vec2 f = fract(p);
  float a = hash(i); float b = hash(i+vec2(1.,0.)); float c = hash(i+vec2(0.,1.)); float d = hash(i+vec2(1.,1.));
  vec2 u = f*f*(3.0-2.0*f);
  return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
}

float metaballField(vec2 p){
  float field = 0.0;
  for(int i=0;i<u_blobCount;i++){
    vec3 b = u_blobs[i];
    vec2 bp = b.xy;
    float r = b.z;
    float d = length((p - bp) * vec2(u_resolution.x/u_resolution.y, 1.0));
    field += (r*r) / (d*d + 0.0001);
  }
  return field;
}

void main(){
  vec2 uv = v_uv;
  vec2 p = uv * u_resolution.xy;

  // normalized coords [0,1]
  vec2 n = uv;

  // compute field
  float f = metaballField(uv);

  // tone threshold to form smooth blobs
  float t = smoothstep(0.25, 0.6, f);

  // create chromatic separation by sampling threshold with offset
  float tR = smoothstep(0.2, 0.55, metaballField(uv - 0.002 * vec2(1.0, 0.0)));
  float tG = smoothstep(0.2, 0.55, metaballField(uv));
  float tB = smoothstep(0.2, 0.55, metaballField(uv + 0.002 * vec2(1.0, 0.0)));

  vec3 blobCol = vec3(tR, tG, tB) * vec3(0.0, 0.95, 0.8);

  // background subtle noise & vignette
  float n1 = noise(uv * 6.0 + u_time*0.02);
  vec3 bg = vec3(0.02 + 0.02*n1, 0.04 + 0.04*n1, 0.06 + 0.04*n1);

  // composite: blend blob color with bg
  vec3 col = mix(bg, blobCol*1.45 + vec3(0.02,0.03,0.05), max(tR, max(tG, tB)));

  // add soft rim glow where field edge is
  float edge = abs(sin(u_time*0.3 + length(uv - u_mouse)*30.0));
  col += vec3(0.015, 0.02, 0.025) * (1.0 - smoothstep(0.0, 0.6, f)) * 0.6;

  // final soft fade
  float vign = smoothstep(0.0, 0.6, length(uv - vec2(0.5)));
  col *= 1.0 - 0.18*vign;

  outColor = vec4(col, 0.7 * (0.2 + 0.8*max(tR, max(tG,tB))));
}
`;

/* helper to compile shader */
function compileShader(gl, source, type){
  const sh = gl.createShader(type);
  gl.shaderSource(sh, source);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(sh));
    return null;
  }
  return sh;
}

/* create program */
let program = null;
let attribs = {}, uniforms = {};
if (glSupported){
  const v = compileShader(gl, vertSrc, gl.VERTEX_SHADER);
  const f = compileShader(gl, fragSrc, gl.FRAGMENT_SHADER);
  if(v && f){
    program = gl.createProgram();
    gl.attachShader(program, v);
    gl.attachShader(program, f);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link error', gl.getProgramInfoLog(program));
      program = null;
      glSupported = false;
    } else {
      gl.useProgram(program);
      // quad
      const quad = new Float32Array([-1,-1,1,-1,-1,1,1,1]);
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
      const loc = gl.getAttribLocation(program, 'a_pos');
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
      // uniforms
      uniforms.u_time = gl.getUniformLocation(program, 'u_time');
      uniforms.u_resolution = gl.getUniformLocation(program, 'u_resolution');
      uniforms.u_mouse = gl.getUniformLocation(program, 'u_mouse');
      uniforms.u_blobCount = gl.getUniformLocation(program, 'u_blobCount');
      // u_blobs indexed uniform array
      // we'll set blobs later
    }
  } else {
    glSupported = false;
  }
}

/* blob storage for shader (max 32) */
let blobs = []; // each {x,y,r}
function spawnBlob(x,y,r){
  // normalized positions for shader [0,1]
  blobs.push({ x: x / glCanvas.width, y: 1.0 - (y / glCanvas.height), r: r / Math.max(glCanvas.width, glCanvas.height) * 1200 });
  if (blobs.length > 32) blobs.shift();
}

/* render loop for WebGL metaballs */
let lastTime = performance.now();
function renderGL(now){
  now = now || performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  if(glSupported && program){
    gl.viewport(0,0,glCanvas.width, glCanvas.height);
    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);
    gl.uniform1f(uniforms.u_time, now * 0.001);
    gl.uniform2f(uniforms.u_resolution, glCanvas.width, glCanvas.height);
    // mouse placeholder (use last pointer)
    gl.uniform2f(uniforms.u_mouse, mousePos.x / glCanvas.width, 1.0 - (mousePos.y / glCanvas.height));
    // blobs
    const count = Math.min(32, blobs.length);
    gl.uniform1i(uniforms.u_blobCount, count);
    // prepare array for u_blobs (vec3 array)
    const arr = new Float32Array(32*3);
    for(let i=0;i<count;i++){
      arr[i*3+0] = blobs[i].x;
      arr[i*3+1] = blobs[i].y;
      arr[i*3+2] = blobs[i].r;
    }
    // upload to uniform (must use gl.uniform3fv with location of array)
    const u_blobs_loc = gl.getUniformLocation(program, 'u_blobs');
    if (u_blobs_loc) {
      gl.uniform3fv(u_blobs_loc, arr);
    }
    // draw quad
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  requestAnimationFrame(renderGL);
}
if (glSupported) requestAnimationFrame(renderGL);

/* ---------------------------
   Mouse & pointer handling
   --------------------------- */
const mousePos = { x: innerWidth/2, y: innerHeight/2 };
window.addEventListener('pointermove', (e)=>{
  mousePos.x = e.clientX; mousePos.y = e.clientY;
});
window.addEventListener('pointerdown', (e)=>{
  spawnBlob(e.clientX, e.clientY, 80 + Math.random()*60);
});

/* ---------------------------
   Card local canvas (GPU fallback ripple + visual) - used when webgl not present or to add local ripple
   --------------------------- */
const cardCtx = cardCanvas.getContext('2d', { alpha:true });
function updateCardCanvas(){
  const w = cardCanvas.width, h = cardCanvas.height;
  cardCtx.clearRect(0,0,w,h);
  // soft vignette
  const grad = cardCtx.createRadialGradient(w*0.5, h*0.3, 0, w*0.5, h*0.5, Math.max(w,h));
  grad.addColorStop(0, 'rgba(255,255,255,0.02)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  cardCtx.fillStyle = grad;
  cardCtx.fillRect(0,0,w,h);
  // draw metaball proxies (from blobs transformed to card local coords)
  for(let i=0;i<blobs.length;i++){
    const b = blobs[i];
    // convert from full canvas normalized to card canvas pos
    // b.x,b.y in [0,1] relative to full glCanvas
    let fullX = b.x * glCanvas.width;
    let fullY = (1.0 - b.y) * glCanvas.height;
    // card rect
    const rect = loginCard.getBoundingClientRect();
    const localX = fullX - (rect.left - 30);
    const localY = fullY - (rect.top - 30);
    if(localX < -200 || localY < -200 || localX > w+200 || localY > h+200) continue;
    const R = b.r * Math.max(glCanvas.width, glCanvas.height);
    const rad = Math.max(12, R*0.9);
    const g = cardCtx.createRadialGradient(localX, localY, 0, localX, localY, rad*1.8);
    g.addColorStop(0, 'rgba(0,250,190,0.16)');
    g.addColorStop(0.35, 'rgba(0,250,190,0.06)');
    g.addColorStop(1, 'rgba(0,250,190,0)');
    cardCtx.fillStyle = g;
    cardCtx.beginPath();
    cardCtx.arc(localX, localY, rad*1.8, 0, Math.PI*2);
    cardCtx.fill();
  }
  requestAnimationFrame(updateCardCanvas);
}
updateCardCanvas();

/* ---------------------------
   Sun & particles 2D (sunrise ray + soft particles)
   --------------------------- */
const sCtx = sunCanvas.getContext('2d', { alpha:true });
const pCtx = particlesCanvas.getContext('2d', { alpha:true });
let sunT = 0;
const softParticles = [];
for(let i=0;i<120;i++){
  softParticles.push({
    x: Math.random()*innerWidth,
    y: Math.random()*innerHeight,
    r: 6 + Math.random()*36,
    hue: 180 + Math.random()*90,
    vx: (Math.random()-0.5)*0.06,
    vy: -0.02 - Math.random()*0.15,
    alpha: 0.02 + Math.random()*0.08
  });
}
function renderSun(now){
  const w = sunCanvas.width, h = sunCanvas.height;
  const dt = 0.016; sunT += dt*0.05;
  sCtx.clearRect(0,0,w,h);
  // rising sunlight center bottom-left
  const gx = w*0.14;
  const gy = h*(0.9 - Math.min(1, sunT)*0.28);
  const rg = sCtx.createRadialGradient(gx, gy, 20, gx, gy, Math.max(w,h)*1.2);
  rg.addColorStop(0, `rgba(255,240,200,${0.09 + Math.min(1,sunT)*0.21})`);
  rg.addColorStop(0.14, `rgba(255,220,180,${0.05 + Math.min(1,sunT)*0.12})`);
  rg.addColorStop(1, 'rgba(255,200,160,0)');
  sCtx.fillStyle = rg;
  sCtx.fillRect(0,0,w,h);
  // volumetric beams (soft)
  for(let i=0;i<3;i++){
    sCtx.save();
    sCtx.globalAlpha = 0.02 + Math.min(1,sunT)*0.06;
    sCtx.translate(gx, gy);
    const angle = -0.55 + i*0.38;
    sCtx.rotate(angle);
    const bw = Math.max(w,h)*1.2;
    const grad = sCtx.createLinearGradient(-bw,0,bw,0);
    grad.addColorStop(0, 'rgba(255,255,240,0)');
    grad.addColorStop(0.5, 'rgba(255,255,240,0.06)');
    grad.addColorStop(1, 'rgba(255,255,240,0)');
    sCtx.fillStyle = grad;
    sCtx.fillRect(-bw, -h*0.45, bw*2, h*1.2);
    sCtx.restore();
  }
  // particles
  pCtx.clearRect(0,0,w,h);
  pCtx.globalCompositeOperation = 'lighter';
  for(let p of softParticles){
    p.x += p.vx * (1 + sunT*2);
    p.y += p.vy * (1 + sunT*0.4);
    p.alpha += (Math.random()-0.5)*0.01;
    if(p.alpha < 0.01) p.alpha = 0.01;
    if(p.x < -200) p.x = w+200;
    if(p.x > w+200) p.x = -200;
    if(p.y < -200) p.y = h+200;
    const grad = pCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
    grad.addColorStop(0, `hsla(${p.hue},90%,65%,${p.alpha})`);
    grad.addColorStop(0.3, `hsla(${p.hue},80%,60%,${p.alpha*0.5})`);
    grad.addColorStop(1, `hsla(${p.hue-30},70%,30%,0)`);
    pCtx.fillStyle = grad;
    pCtx.beginPath(); pCtx.arc(p.x, p.y, p.r, 0, Math.PI*2); pCtx.fill();
  }
  requestAnimationFrame(renderSun);
}
requestAnimationFrame(renderSun);

/* ---------------------------
   Physics drag for login card (spring back)
   --------------------------- */
let dragging = false;
let dragOffset = {x:0,y:0}, origin = {x:0,y:0}, vel = {x:0,y:0};
function startDrag(e){
  dragging = true;
  loginCard.style.transition = 'none';
  const rect = loginCard.getBoundingClientRect();
  dragOffset.x = e.clientX - rect.left;
  dragOffset.y = e.clientY - rect.top;
  origin.x = rect.left; origin.y = rect.top;
}
function moveDrag(e){
  if(!dragging) return;
  const px = e.clientX - dragOffset.x;
  const py = e.clientY - dragOffset.y;
  const dx = px - origin.x, dy = py - origin.y;
  vel.x = dx * 0.2; vel.y = dy * 0.2;
  loginCard.style.transform = `translate(${dx}px, ${dy}px) rotateX(${ -dy/80 }deg) rotateY(${ dx/80 }deg)`;
  spawnBlob(e.clientX, e.clientY, 60 + Math.random()*40);
}
function endDrag(){
  if(!dragging) return;
  dragging = false;
  // spring back
  let px = 0, py = 0;
  let vxx = vel.x, vyy = vel.y;
  const spring = 0.09, damp = 0.82;
  function step(){
    const ax = -spring * px, ay = -spring * py;
    vxx = (vxx + ax) * damp; vyy = (vyy + ay) * damp;
    px += vxx; py += vyy;
    loginCard.style.transform = `translate(${px}px, ${py}px) rotateX(${ -py/80 }deg) rotateY(${ px/80 }deg)`;
    if(Math.abs(px) + Math.abs(py) > 0.5 || Math.abs(vxx) + Math.abs(vyy) > 0.02){
      requestAnimationFrame(step);
    } else {
      loginCard.style.transition = 'transform 260ms cubic-bezier(.22,.9,.34,1)';
      loginCard.style.transform = '';
    }
  }
  requestAnimationFrame(step);
}
loginCard.addEventListener('pointerdown', (e) => { startDrag(e); loginCard.setPointerCapture(e.pointerId); });
window.addEventListener('pointermove', moveDrag);
window.addEventListener('pointerup', endDrag);

/* ---------------------------
   Menu & domain handling, login flow
   --------------------------- */
const loginEmail = document.getElementById('loginEmail');
const loginUser = document.getElementById('loginUser');
const loginPass = document.getElementById('loginPass');
const loginBtnEl = document.getElementById('loginBtn');
const menuList = document.getElementById('menuList');

menuButtons.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    menuButtons.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    const id = btn.dataset.id;
    selectDomain(id);
  });
});

function selectDomain(id){
  state.selectedDomain = id;
  if(id==='cvwt'){ domainTitle.textContent='CVWT'; domainDesc.textContent='Chill Verse Website Testers — test & chill with site builds.'; domainArt.style.backgroundImage = `url('${CARD_ART_URL}')`;}
  if(id==='coders'){ domainTitle.textContent='Coders Association'; domainDesc.textContent='Collab on code, review & ship products.'; domainArt.style.backgroundImage = `url('${CARD_ART_URL}')`;}
  if(id==='editors'){ domainTitle.textContent='Editors Club'; domainDesc.textContent='Editing & publishing workflows.'; domainArt.style.backgroundImage = `url('${CARD_ART_URL}')`;}
  if(id==='office'){ domainTitle.textContent='Office Holders Verse'; domainDesc.textContent='Leadership roles and governance.'; domainArt.style.backgroundImage = `url('${CARD_ART_URL}')`;}
}

/* LOGIN: real validate fields and then slide transition (option 2) */
loginBtnEl.addEventListener('click', ()=>{
  const e = loginEmail.value.trim(); const u = loginUser.value.trim(); const p = loginPass.value;
  if(!e || !u || !p){
    shake(loginCard);
    return alert('Fill email, username and password');
  }
  // store session (not password)
  state.logged = true; state.username = u; state.email = e; state.passwd = p;
  localStorage.setItem('domain_ui_user', JSON.stringify({ username: u, email: e }));
  // slide transition: shell slides left, dashboard slides in from right
  shell.style.transition = 'transform 420ms cubic-bezier(.22,.9,.34,1), opacity 360ms';
  shell.style.transform = 'translateX(-40px)';
  shell.style.opacity = '0';
  setTimeout(()=>{
    shell.style.display = 'none';
    const dash = document.getElementById('dashboardWrap');
    dash.style.display = 'block';
    dash.style.opacity = '0';
    dash.style.transform = 'translateX(40px)';
    setTimeout(()=>{ dash.style.transition = 'transform 420ms cubic-bezier(.22,.9,.34,1), opacity 360ms'; dash.style.transform = 'translateX(0)'; dash.style.opacity = '1'; }, 40);
  }, 420);
  selectDomain('cvwt');
});

/* logout */
document.getElementById('logoutBtn').addEventListener('click', ()=>{
  state.logged = false; state.username = null; state.email = null; state.passwd = null;
  localStorage.removeItem('domain_ui_user');
  document.getElementById('dashboardWrap').style.display = 'none';
  document.getElementById('shell').style.display = 'flex';
  loginPass.value = '';
});

/* re-auth + join flow */
let pendingDomain = null;
joinBtn.addEventListener('click', ()=> {
  pendingDomain = state.selectedDomain;
  document.getElementById('authModal').style.display = 'block';
});
document.getElementById('reCancel').addEventListener('click', ()=> document.getElementById('authModal').style.display = 'none');
document.getElementById('reSubmit').addEventListener('click', ()=>{
  const val = document.getElementById('rePass').value || '';
  if(val === state.passwd){
    document.getElementById('authModal').style.display = 'none';
    openJoinModal();
  } else {
    alert('Password incorrect');
  }
});
function openJoinModal(){
  document.getElementById('joinModal').style.display = 'block';
  document.getElementById('joinEmail').value = state.email || '';
}
document.getElementById('joinCancel').addEventListener('click', ()=> document.getElementById('joinModal').style.display = 'none');
document.getElementById('joinSubmit').addEventListener('click', async ()=>{
  const em = document.getElementById('joinEmail').value.trim();
  if(!em) return alert('Enter email to join');
  const payload = { domain: state.selectedDomain.toUpperCase(), email: em, username: state.username };
  try {
    await fetch(SCRIPT_URL, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
    document.getElementById('joinModal').style.display = 'none';
    showSuccess(`Registered for ${payload.domain}. Check ${em}.`);
  } catch(err){
    console.error(err);
    alert('Failed to register — try again');
  }
});
function showSuccess(msg){
  document.getElementById('successMsg').textContent = msg;
  document.getElementById('successModal').style.display = 'block';
}
document.getElementById('succClose').addEventListener('click', ()=> document.getElementById('successModal').style.display = 'none');

/* hydrate saved user */
(function hydrate(){
  const saved = localStorage.getItem('domain_ui_user');
  if(saved){
    try{
      const o = JSON.parse(saved);
      if(o.username) loginUser.value = o.username;
      if(o.email) loginEmail.value = o.email;
    } catch(e){}
  }
})();

/* small shake util */
function shake(el){
  el.animate([{ transform: 'translateX(0)' }, { transform: 'translateX(-8px)' },{ transform: 'translateX(8px)' },{ transform: 'translateX(-6px)' },{ transform: 'translateX(6px)' },{ transform: 'translateX(0)' }], { duration:420, easing:'cubic-bezier(.3,.8,.3,1)'});
}

/* helpful: ensure canvases sized */
fitFullCanvas();
fitCardCanvas();
</script>
</body>
</html>

